<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>分布式事务</title>
      <link href="/2023/03/18/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
      <url>/2023/03/18/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<p><strong>出现原因：</strong><br>在分布式场景下，完成一次写入操作，需要同时协调多个系统，分布式事务需要保证这些操作要么全部成功要么全部失败。</p><p>以常见的交易下单为例，当用户下单之后，订单系统生成订单，商品系统扣减库存，促销系统扣减优惠券，只有当三个系统的事务都提交之后，才认为这次下单成功，否则失败</p><p>这是一个典型的分布式事务问题，解决方案有两阶段提交协议，3阶段提交协议，TCC和基于消息队列的实现方式。在实际的工作中，基本都是基于MQ的可靠消息投递来实现的。强一致的场景（比如金融业务）会基于2PC和3PC这两种方式实现。</p><h2 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a>2PC</h2><ul><li><p>准备阶段：事务管理器首先会通知所有资源管理器开启事务，如果资源管理器此时会将undo日志和redo日志计入事务日志中，并做出应答，当协调者接收到反馈Yes之后，则准备阶段结束。</p><ul><li>如果任何一个参与者向协调者反馈了No响应，此时协调者向所有参与者发出Rollback请求，参与者接收rollback请求之后，会利用其在准备阶段中记录的undo日志进行回滚操作，并且在完成事务回滚之后向协调者发送Ack消息，完成事务回滚操作。</li></ul></li><li><p>提交阶段：当收到所有数据库实例的Yes之后，事务管理器会发出提交指令。每个数据库接受指令进行本地操作，正式提交更新数据，然后向协调者返回Ack消息，事务结束。</p></li><li><p>缺陷：资源锁定会产生死锁问题，同时会带来性能下降的风险。面对数据不一致的问题，有数据库提交事务了，有数据库没有提交事务</p></li></ul><h2 id="基于MQ的可靠消息投递方案"><a href="#基于MQ的可靠消息投递方案" class="headerlink" title="基于MQ的可靠消息投递方案"></a>基于MQ的可靠消息投递方案</h2><ul><li><p>放弃强一致性，选择最终一致性。基于 MQ 的可靠消息投递的方案不仅可以解决由于业务流程的同步执行而造成的阻塞问题，还可以实现业务解耦合流量削峰。</p><blockquote><ul><li>还是拿下单场景举例，当订单系统调用优惠券系统时，将扣减优惠券的事件放入消息队列中，最终给优惠券系统来执行，然后只要保证事件消息能够在优惠券系统内被执行就可以了，因为消息已经持久化在消息中间件中，即使消息中间件发生了宕机，我们将它重启后也不会出现消息丢失的问题。</li></ul></blockquote></li><li><p>消息丢了怎么办？</p><ul><li>只有执行业务完成，消息队列才能删除这条持久化消息。所以需要手动发Ack</li></ul></li><li><p>消息太多怎么办？</p><ul><li><p>消息队列会不断地重试，如果超过了最大重试次数会被丢弃到死信队列中，不再处理。但是发送方需要知道该消息还没有被处理，需要重新投递。</p><ul><li>实现：持久化要发送的消息，记录未完成状态。通过定时扫描，将未完成的消息重新投递来进行消息补偿，完成双向消息确认</li></ul></li></ul></li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E7%B2%BE%E8%AE%B2/05%20%20%E6%B5%B7%E9%87%8F%E5%B9%B6%E5%8F%91%E5%9C%BA%E6%99%AF%E4%B8%8B%EF%BC%8C%E5%A6%82%E4%BD%95%E5%9B%9E%E7%AD%94%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98%EF%BC%9F.md"># 海量并发场景下，如何回答分布式事务一致性问题？</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="/2023/03/11/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/03/11/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>非原创，仅搬运</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>单例模式是一种设计模式，它的目的是保证一个类只有一个实例，并提供一个全局的访问点。使用单例模式可以避免多次创建对象，节省内存空间，同时也可以保证数据的一致性。在开发过程中使用单例模式有以下好处：</p><ol><li>节省内存空间。单例模式只创建一个实例，避免了多次创建对象所造成的内存消耗。</li><li>简化代码。单例模式提供了一个全局的访问点，可以方便地调用实例的方法，避免了重复的代码。</li><li>保证数据的一致性。由于只有一个实例，可以避免并发访问时数据不一致的问题。</li></ol><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>实现单例模式的方式有很多，下面是一些常见实现单例模式的方式：</p><ol><li>饿汉式单例模式：在类加载时就创建了实例，因此保证了线程安全。但是可能会造成资源浪费，因为实例在使用前就已经创建了。</li><li>懒汉式单例模式：实例的创建是在第一次使用时才进行的。这种方式需要注意线程安全，可以使用synchronized关键字或者双重检查锁定等方式来保证线程安全。</li><li>静态内部类单例模式：这种方式可以保证线程安全，且实现简单。实例的创建是在第一次使用时才进行的。</li><li>枚举单例模式：这种方式可以保证线程安全，且实现简单。枚举类型的属性在Java中只会被初始化一次，因此枚举单例模式可以保证只有一个实例。</li><li>双重检查锁定单例模式：这种方式可以保证线程安全，且实现相对简单。在第一次调用getInstance()方法时进行了双重检查，保证了只有一个实例被创建。</li><li>线程局部变量单例模式：这种方式可以保证线程安全，且实现简单。在单个线程内部只会创建一个实例，因此不会造成资源浪费。</li></ol><blockquote><p>这里提供一种使用了双重检查锁的线程安全方式实现单例模式</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line"></span><br><span class="line">    // 私有构造方法private Singleton() &#123;&#125;</span><br><span class="line">    // 使用volatile禁止单例对象创建时的重排序private static volatile Singleton instance;</span><br><span class="line"></span><br><span class="line">   // 对外提供静态方法获取该对象public static Singleton getInstance() &#123;</span><br><span class="line">                // 第一次判断，如果instance不为null，不进入抢锁阶段，直接返回实际if(instance == null) &#123;</span><br><span class="line">            synchronized (Singleton.class) &#123;</span><br><span class="line">                // 抢到锁之后再次判断是否为空if(instance == null) &#123;</span><br><span class="line">                    instance = new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>这些不同的实现方式各有优缺点，在项目开发过程中需要根据场景需求选择合适的实现方式</p><table><thead><tr><th>实现方式</th><th>线程安全性</th><th>实现复杂度</th><th>资源浪费</th></tr></thead><tbody><tr><td>饿汉式单例模式</td><td>线程安全</td><td>简单</td><td>可能会造成资源浪费</td></tr><tr><td>懒汉式单例模式</td><td>需要注意线程安全</td><td>较复杂</td><td>可能会造成资源浪费(线程不安全)</td></tr><tr><td>静态内部类单例模式</td><td>线程安全</td><td>简单</td><td>不会造成资源浪费</td></tr><tr><td>枚举单例模式</td><td>线程安全</td><td>简单</td><td>不会造成资源浪费</td></tr><tr><td>双重检查锁定单例模式</td><td>线程安全</td><td>较复杂</td><td>不会造成资源浪费</td></tr><tr><td>线程局部变量单例模式</td><td>线程安全</td><td>简单</td><td>不会造成资源浪费</td></tr></tbody></table><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>单例模式在开发中有许多适用的场景，如：</p><ol><li>数据库连接池：在多线程环境下，为了避免频繁地创建和释放数据库连接，可以使用单例模式来实现数据库连接池，保证系统中只有一个连接池实例；</li><li>应用程序配置信息对象：在系统中需要读取应用程序配置信息时，为了避免重复读取和存储配置信息，可以使用单例模式来实现配置信息对象，保证系统中只有一个配置信息对象实例；</li><li>线程池：在多线程环境下，为了避免频繁地创建和销毁线程，可以使用单例模式来实现线程池，保证系统中只有一个线程池实例。</li></ol><p>在我们日常开发中接触到的Java和Spring也有许多地方应用了单例模式：</p><ol><li>在Java中，<code>Runtime类</code>就是一个单例模式。这个类提供了访问Java虚拟机的运行时环境的方法，比如获取内存信息、获取CPU核心数等。由于每个Java应用程序只有一个Java虚拟机实例，因此Runtime类只需要一个实例即可，这就是单例模式的应用。</li><li>在Spring框架中，<code>ApplicationContext对象</code>也是一个单例模式。ApplicationContext对象是Spring框架中的容器对象，负责管理Bean对象的创建、初始化、依赖注入等操作。由于ApplicationContext对象的创建和初始化需要消耗大量的系统资源，因此在整个应用程序中只需要一个ApplicationContext对象实例即可，这就是单例模式的应用。</li></ol><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>单例模式虽然好，但是任何设计模式都会存在其弊端，因此在使用过程中需要注意以下问题：</p><ol><li>线程安全问题。这个问题在饿汉式中是一个常见的问题，普通的饿汉式方案在多线程情况下容易出现并发问题导致创建多个不同的示例，因此在实现方案中可以使用<code>加锁的方式</code>保证线程的安全；</li><li>序列化和反序列化问题。在单例模式中存在着破坏单例的风险，而序列化和反序列化便是其中之一。当我们使用序列化和反序列化创建单例对象时会发现创建出来的对象都是不一样的，违背了单例模式的初衷，因此在需要序列化和反序列化类中实现实现<code>Serializable接口</code>，并且提供一个<code>readResolve()方法</code>，以保证反序列化后仍然是同一个实例；</li><li>反射问题。使用单例模式时，需要考虑防止反射攻击。因为破坏单例的另外一种方式便是反射，就算是前面提及到的序列化和反序列化问题，底层也是通过反射来破坏单例的。因此在开发过程中可以在构造方法中判断是否已经存在实例，如果存在则抛出异常，防止通过反射创建新的实例。</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/03/11/hello-world/"/>
      <url>/2023/03/11/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
